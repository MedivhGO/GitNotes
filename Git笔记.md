# Git笔记
git分布式版本控制系统.

每一个开发者都同事拥有一个相当于当前文件操作的**工作区**与一个用于存储该项目所有版本,分支,以及标签的**本地版本库**.

开发者A          开发者B
A                   A

A->B                A->C

A->B->
 ->C ->D

开发者A导入了开发者B所做的修改,二人的修改会被合并在一起,形成一个新的提交.

我们可以对分支历史进行改造,排序和删除.

有利于为该项目建立更好的历史文档,我们称这种处理为交互式重订(interactive rebasing)

## 创建版本库

在该项目的目录中使用git init命令,对于一个带版本库的项目目录,我们称之为**交互区**.

当在git管理的目录中添加了新文件却没有add,那么这个文件并未注册到版本库.会显示**untracked file**

git status 只会对已经add过的文件进行标记.

delete: bar.txt

modified: foo.txt

所有的修改都必须要都必须要先被归档成一次新的提交.

对修改过的文件和新文件执行add

对删除的文件执行rm

归纳后使用git commit -m 进行提交


pull命令从原版本库中取回了新的修改,将他们与克隆体中的本地修改进行对比,并在工作区中合并两边的修改,创建一次新的提交,这个过程就是所谓的合并.

*
| \
|  *
*  |
|  *
*  |

每一个*代表依次提交

使用push命令上载修改

git  push将修改上传到共享版本库

如果另一个开发者在我们之前已经做过一次push操作,此次push命令就会被拒绝,这时候要先做一次pull操作,将其他上载的更新取回并在本地合并.

为了让克隆版本库也得到相应的修改,我们需要在clone版本库执行pull命令.


在git中,恢复到某一版本通常称之为checkout(检出)操作.

在git中每一个开发者都有一个属于自己的版本库克隆体.每个人在一段开发过后就有了一部不同于其他开发者的版本库历史.

git log -n 3 显示该项目的最后3次提交

git log --oneline 每次提交只显示一行

多次提交

提交的产生通常分为两个步骤

1. 使用add命令将所有相关的修改纳入到一个缓存区(staging area 或 index)


git status: 显示的状态

1. change to be committed: 下次提交被纳入版本库中,被修改的文件.
2. changed but not update
3. untraced files

在git中更新则是指将工作区中的修改集中到暂存区中

git status --short

工作区中发生了很多修改,使用--short选项,以便相关输出显示的更紧凑一些.

## 选择性提交
1.git status 位于上文提到的2,3尚未被注册为下次提交的文件

2. 收集相关修改

3. 创建提交

暂存区不仅要存储修改所发生的位置,同时也要存储修改的内容.

git diff 在不带任何选项的情况下,diff命令所显示的就是工作区中尚未被注册的本地修改.
就是显示暂存区与工作区的不同之处.

### git stash 

如果我们在某些事情进行到中间的时候突然发现自己需要快速修复某个问题.

git stash 将保存工作区与暂存区.

## 分支

使用git checkout 分支名   //来切换分支

git branch 分支名  //创建分支

git checkout -b 分支名 //创建并切换分支

工作区或暂存区存在着一些修改,则需要提交后切换分支.

## 删除分支

git branch -d 分支名 //已被终止的分支

git branch -D 分支名 //活跃的也删除

## 恢复被删除的分支

git branch 分支名 (散列值)

git reflog 查看分支散列值

## 合并分支:

A-B-E
  \C-D
 
A-B-E-F
  \   /
  C-D

E D合并时会发生冲突  


## 冲突

编辑冲突: 通常发生在两个开发者对同一行代码做出了不同修改的时候.

内容冲突: 通常发生在两个开发者对某份代码的n个部分作出果子修改的时候.

1. 工作区中的文件代表了合并结果.
2. 无冲突部分的修改合并将会记录在**暂存区**中以便下一次提交.
3. 将会有冲突表示被插入
4. 冲突所在之外会注册到下一次提交中

首先是这些修改的行在当前分支(head)中的内容

接下来列出他们在另一个分支(MERGE_HEAD)中的内容.如下所示:

```
<<<<HEAD 
to .... the valley

======

for swimming

>>>>one-branch
```



## git tag

我们常常在代码封板时,使用git 创建一个tag ,这样一个不可修改的历史代码版本就像被我们封存起来一样,不论是运维发布拉取,或者以后的代码版本管理,都是十分方便的

git 下打标签其实有2种情况

轻量级的：它其实是一个独立的分支,或者说是一个不可变的分支.指向特定提交对象的引用

带附注的：实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证,电子邮件地址和日期，一般我们都建议使用含附注型的标签，以便保留相关信息